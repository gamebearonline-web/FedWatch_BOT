name: FOMC YF PRE (5min before)

on:
  workflow_dispatch:
    inputs:
      text_prefix:
        description: "Prefix text"
        required: false
        default: "üü°FOMC 5ÂàÜÂâçÔΩúÂÖàÁâ©„ÅÆÊ∞¥Ê∫ñ"
      dry_run:
        description: "true/false"
        required: false
        default: "false"

jobs:
  run:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install deps
        run: |
          pip install yfinance==0.2.43 pytz==2024.1

      - name: Build tweet text (safe)
        id: tw
        env:
          PREFIX: ${{ inputs.text_prefix }}
        run: |
          python - << 'PY'
          import datetime as dt
          import yfinance as yf
          import pytz
          import os, time

          prefix = os.environ["PREFIX"]
          tz = pytz.timezone("Asia/Tokyo")
          now = dt.datetime.now(tz).strftime("%Y-%m-%d %H:%M JST")

          tickers = {
              "ES": "ES=F",
              "NQ": "NQ=F",
              "YM": "YM=F",
              "TNX": "^TNX",
          }

          def fetch_price(tkr, retry=3, sleep_sec=5):
              for i in range(retry):
                  try:
                      t = yf.Ticker(tkr)

                      # fast_info
                      fi = getattr(t, "fast_info", None)
                      if fi and fi.get("last_price") is not None:
                          return float(fi["last_price"])

                      # 1ÂàÜË∂≥
                      hist = t.history(period="1d", interval="1m", auto_adjust=False)
                      if not hist.empty:
                          return float(hist["Close"].dropna().iloc[-1])

                  except Exception as e:
                      pass

                  time.sleep(sleep_sec)

              return None  # Âèñ„Çå„Å™„Åë„Çå„Å∞ None

          values = {}
          for k, tkr in tickers.items():
              p = fetch_price(tkr)
              if p is None:
                  values[k] = None
                  continue

              if k == "TNX" and p > 20:
                  p = p / 10.0
              values[k] = p

          def fmt(sym, v):
              if v is None:
                  return "N/A"
              if sym == "TNX":
                  return f"{v:.3f}%"
              return f"{v:.2f}"

          text = (
              f"{prefix}\n"
              f"ES {fmt('ES', values['ES'])} / "
              f"NQ {fmt('NQ', values['NQ'])} / "
              f"YM {fmt('YM', values['YM'])}\n"
              f"Á±≥10Âπ¥ {fmt('TNX', values['TNX'])}\n"
              f"({now})\n"
              f"#FOMC"
          )

          open("tweet.txt", "w", encoding="utf-8").write(text)
          print(text)
          PY

          echo "text<<EOF" >> $GITHUB_OUTPUT
          cat tweet.txt >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Post to X (OAuth1) - text only
        env:
          DRY_RUN: ${{ inputs.dry_run }}
          X_API_KEY: ${{ secrets.X_API_KEY }}
          X_API_KEY_SECRET: ${{ secrets.X_API_KEY_SECRET }}
          X_ACCESS_TOKEN: ${{ secrets.X_ACCESS_TOKEN }}
          X_ACCESS_TOKEN_SECRET: ${{ secrets.X_ACCESS_TOKEN_SECRET }}
          TWEET_TEXT: ${{ steps.tw.outputs.text }}
        run: |
          if [ "$DRY_RUN" = "true" ]; then
            echo "DRY RUN:"
            echo "$TWEET_TEXT"
            exit 0
          fi

          node << 'EOF'
          const crypto = require("crypto");
          const https = require("https");

          const text = process.env.TWEET_TEXT;
          const apiKey = process.env.X_API_KEY;
          const apiKeySecret = process.env.X_API_KEY_SECRET;
          const accessToken = process.env.X_ACCESS_TOKEN;
          const accessTokenSecret = process.env.X_ACCESS_TOKEN_SECRET;

          function pct(s){return encodeURIComponent(s).replace(/[!*()']/g,c=>"%" + c.charCodeAt(0).toString(16));}
          function nonce(){return crypto.randomBytes(16).toString("hex");}
          function ts(){return Math.floor(Date.now()/1000).toString();}

          function oauthHeader(method, url) {
            const u = new URL(url);
            const baseUrl = u.origin + u.pathname;
            const params = {
              oauth_consumer_key: apiKey,
              oauth_nonce: nonce(),
              oauth_signature_method: "HMAC-SHA1",
              oauth_timestamp: ts(),
              oauth_token: accessToken,
              oauth_version: "1.0",
            };
            const sorted = Object.keys(params).sort().map(k => `${pct(k)}=${pct(params[k])}`).join("&");
            const base = [method, pct(baseUrl), pct(sorted)].join("&");
            const key = `${pct(apiKeySecret)}&${pct(accessTokenSecret)}`;
            params.oauth_signature = crypto.createHmac("sha1", key).update(base).digest("base64");
            return "OAuth " + Object.keys(params).map(k => `${pct(k)}="${pct(params[k])}"`).join(", ");
          }

          function postJson(url, payload){
            return new Promise((resolve, reject) => {
              const body = Buffer.from(JSON.stringify(payload));
              const req = https.request(url, {
                method: "POST",
                headers: {
                  "Authorization": oauthHeader("POST", url),
                  "Content-Type": "application/json",
                  "Content-Length": body.length
                }
              }, res => {
                let data = "";
                res.on("data", c => data += c);
                res.on("end", () => resolve({status: res.statusCode, body: data}));
              });
              req.on("error", reject);
              req.write(body);
              req.end();
            });
          }

          (async () => {
            const r = await postJson("https://api.twitter.com/2/tweets", { text });
            console.log("Tweet result:", r.status);
          })().catch(e => {
            console.error(e);
            process.exit(0); // ÊäïÁ®øÂ§±Êïó„Åß„ÇÇ workflow „ÅØÊàêÂäüÊâ±„ÅÑ
          });
          EOF
