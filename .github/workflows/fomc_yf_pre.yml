name: FOMC YF PRE (5min before)

on:
  workflow_dispatch:
    inputs:
      text_prefix:
        description: "Prefix text"
        required: false
        default: "üü°FOMC 5ÂàÜÂâçÔΩúÂÖàÁâ©„ÅÆÊ∞¥Ê∫ñ"
      dry_run:
        description: "true/false"
        required: false
        default: "false"

jobs:
  run:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install deps
        run: |
          pip install yfinance==0.2.43 pytz==2024.1

      - name: Build tweet text (safe + base64 output)
        id: tw
        env:
          PREFIX: ${{ inputs.text_prefix }}
        run: |
          python - << 'PY'
          import datetime as dt
          import yfinance as yf
          import pytz
          import os, time

          prefix = os.environ.get("PREFIX", "üü°FOMC 5ÂàÜÂâçÔΩúÂÖàÁâ©„ÅÆÊ∞¥Ê∫ñ")
          tz = pytz.timezone("Asia/Tokyo")
          now = dt.datetime.now(tz).strftime("%Y-%m-%d %H:%M JST")

          tickers = {
              "ES": "ES=F",
              "NQ": "NQ=F",
              "YM": "YM=F",
              "TNX": "^TNX",  # 10Âπ¥ÈáëÂà©ÔºàÊåáÊï∞Ôºâ
          }

          def fetch_price_once(tkr: str):
              t = yf.Ticker(tkr)

              # ‚ë† fast_infoÔºàÂèñ„Çå„Çå„Å∞ÊúÄÈÄüÔºâ
              fi = getattr(t, "fast_info", None)
              if fi and fi.get("last_price") is not None:
                  return float(fi["last_price"])

              # ‚ë° Áõ¥Ëøë1ÂàÜË∂≥ÔºàquoteSummary„ÇíÈÅø„Åë„ÇãÔºù429ËÄêÊÄß„ÅåÈ´ò„ÅÑÔºâ
              hist = t.history(period="1d", interval="1m", auto_adjust=False)
              if hist is not None and not hist.empty:
                  s = hist["Close"].dropna()
                  if len(s) > 0:
                      return float(s.iloc[-1])

              return None

          def fetch_price(tkr: str, retry=3, sleep_sec=5):
              last = None
              for _ in range(retry):
                  try:
                      last = fetch_price_once(tkr)
                      if last is not None:
                          return last
                  except Exception:
                      pass
                  time.sleep(sleep_sec)
              return None

          values = {}
          for k, tkr in tickers.items():
              p = fetch_price(tkr)
              if p is None:
                  values[k] = None
                  continue
              # ^TNX „Åå 45.0 „ÅÆ„Çà„ÅÜ„Å´ 10ÂÄçË°®Á§∫„Å´„Å™„ÇãÂ†¥Âêà„Åå„ÅÇ„Çã„ÅÆ„ÅßË£úÊ≠£
              if k == "TNX" and p > 20:
                  p = p / 10.0
              values[k] = p

          def fmt(sym, v):
              if v is None:
                  return "N/A"
              if sym == "TNX":
                  return f"{v:.3f}%"
              return f"{v:.2f}"

          text = (
              f"{prefix}\n"
              f"ES {fmt('ES', values['ES'])} / NQ {fmt('NQ', values['NQ'])} / YM {fmt('YM', values['YM'])}\n"
              f"Á±≥10Âπ¥ {fmt('TNX', values['TNX'])}\n"
              f"({now})\n"
              f"#FOMC"
          )

          with open("tweet.txt", "w", encoding="utf-8") as f:
              f.write(text)

          print(text)
          PY

          # ‚úÖ delimiterÊñπÂºè„ÇíÊç®„Å¶„Å¶ Base64 „Åß outputs „Å´Ëºâ„Åõ„ÇãÔºà100%Â£ä„Çå„Å™„ÅÑÔºâ
          ENCODED=$(base64 -w 0 tweet.txt)
          echo "text_b64=$ENCODED" >> "$GITHUB_OUTPUT"

      - name: Post to X (OAuth1) - text only
        env:
          DRY_RUN: ${{ inputs.dry_run }}
          X_API_KEY: ${{ secrets.X_API_KEY }}
          X_API_KEY_SECRET: ${{ secrets.X_API_KEY_SECRET }}
          X_ACCESS_TOKEN: ${{ secrets.X_ACCESS_TOKEN }}
          X_ACCESS_TOKEN_SECRET: ${{ secrets.X_ACCESS_TOKEN_SECRET }}
          TWEET_TEXT_B64: ${{ steps.tw.outputs.text_b64 }}
        run: |
          # Base64Âæ©Âè∑
          TWEET_TEXT=$(echo "$TWEET_TEXT_B64" | base64 -d)

          if [ "$DRY_RUN" = "true" ]; then
            echo "DRY RUN:"
            echo "$TWEET_TEXT"
            exit 0
          fi

          node << 'EOF'
          const crypto = require("crypto");
          const https = require("https");

          const text = process.env.TWEET_TEXT;
          const apiKey = process.env.X_API_KEY;
          const apiKeySecret = process.env.X_API_KEY_SECRET;
          const accessToken = process.env.X_ACCESS_TOKEN;
          const accessTokenSecret = process.env.X_ACCESS_TOKEN_SECRET;

          function pct(s){return encodeURIComponent(s).replace(/[!*()']/g,c=>"%" + c.charCodeAt(0).toString(16));}
          function nonce(){return crypto.randomBytes(16).toString("hex");}
          function ts(){return Math.floor(Date.now()/1000).toString();}

          function oauthHeader(method, url) {
            const u = new URL(url);
            const baseUrl = u.origin + u.pathname;
            const params = {
              oauth_consumer_key: apiKey,
              oauth_nonce: nonce(),
              oauth_signature_method: "HMAC-SHA1",
              oauth_timestamp: ts(),
              oauth_token: accessToken,
              oauth_version: "1.0",
            };
            const sorted = Object.keys(params).sort().map(k => `${pct(k)}=${pct(params[k])}`).join("&");
            const base = [method, pct(baseUrl), pct(sorted)].join("&");
            const key = `${pct(apiKeySecret)}&${pct(accessTokenSecret)}`;
            params.oauth_signature = crypto.createHmac("sha1", key).update(base).digest("base64");
            return "OAuth " + Object.keys(params).map(k => `${pct(k)}="${pct(params[k])}"`).join(", ");
          }

          function postJson(url, payload){
            return new Promise((resolve, reject) => {
              const body = Buffer.from(JSON.stringify(payload));
              const req = https.request(url, {
                method: "POST",
                headers: {
                  "Authorization": oauthHeader("POST", url),
                  "Content-Type": "application/json",
                  "Content-Length": body.length
                }
              }, res => {
                let data = "";
                res.on("data", c => data += c);
                res.on("end", () => resolve({status: res.statusCode, body: data}));
              });
              req.on("error", reject);
              req.write(body);
              req.end();
            });
          }

          (async () => {
            const r = await postJson("https://api.twitter.com/2/tweets", { text });
            console.log("Tweet result:", r.status);
            // ÊäïÁ®ø„ÅåÂ§±Êïó„Åó„Å¶„ÇÇ workflow Ëá™‰Ωì„ÅØËêΩ„Å®„Åï„Å™„ÅÑÔºàÈÅãÁî®ÂÑ™ÂÖàÔºâ
          })().catch(e => {
            console.error(e);
            process.exit(0);
          });
          EOF
        env:
          TWEET_TEXT: ${{ env.TWEET_TEXT }}
