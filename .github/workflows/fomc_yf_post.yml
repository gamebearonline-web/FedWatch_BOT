name: FOMC YF POST (15min after)

on:
  workflow_dispatch:
    inputs:
      text_prefix:
        description: "Prefix text"
        required: false
        default: "üü¢FOMC 15ÂàÜÂæåÔΩúÂÖàÁâ©„ÅÆÊ∞¥Ê∫ñ"
      dry_run:
        description: "true/false"
        required: false
        default: "false"

jobs:
  run:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install deps
        run: |
          pip install yfinance==0.2.43 pytz==2024.1

      - name: Build tweet text
        id: tw
        env:
          PREFIX: ${{ inputs.text_prefix }}
        run: |
          python - << 'PY'
          import datetime as dt
          import yfinance as yf
          import pytz
          import os

          prefix = os.environ["PREFIX"]
          tz = pytz.timezone("Asia/Tokyo")
          now = dt.datetime.now(tz).strftime("%Y-%m-%d %H:%M JST")

          tickers = {"ES":"ES=F","NQ":"NQ=F","YM":"YM=F","TNX":"^TNX"}

          def last_price(tkr):
            t = yf.Ticker(tkr)
            fi = getattr(t, "fast_info", None)
            if fi and fi.get("last_price") is not None:
              return float(fi["last_price"])
            info = t.get_info()
            for k in ("regularMarketPrice","previousClose"):
              if info.get(k) is not None:
                return float(info[k])
            raise RuntimeError(f"no price for {tkr}")

          v = {}
          for k,tkr in tickers.items():
            p = last_price(tkr)
            if k == "TNX" and p > 20:
              p = p / 10.0
            v[k] = p

          text = (
            f"{prefix}\n"
            f"ES {v['ES']:.2f} / NQ {v['NQ']:.2f} / YM {v['YM']:.2f}\n"
            f"Á±≥10Âπ¥ {v['TNX']:.3f}%\n"
            f"({now})\n"
            f"#FOMC"
          )

          open("tweet.txt","w",encoding="utf-8").write(text)
          print(text)
          PY

          echo "text<<EOF" >> $GITHUB_OUTPUT
          cat tweet.txt >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Post to X (OAuth1) - text only
        env:
          DRY_RUN: ${{ inputs.dry_run }}
          X_API_KEY: ${{ secrets.X_API_KEY }}
          X_API_KEY_SECRET: ${{ secrets.X_API_KEY_SECRET }}
          X_ACCESS_TOKEN: ${{ secrets.X_ACCESS_TOKEN }}
          X_ACCESS_TOKEN_SECRET: ${{ secrets.X_ACCESS_TOKEN_SECRET }}
          TWEET_TEXT: ${{ steps.tw.outputs.text }}
        run: |
          if [ "$DRY_RUN" = "true" ]; then
            echo "DRY RUN: $TWEET_TEXT"
            exit 0
          fi

          node << 'EOF'
          const crypto = require("crypto");
          const https = require("https");

          const text = process.env.TWEET_TEXT;
          const apiKey = process.env.X_API_KEY;
          const apiKeySecret = process.env.X_API_KEY_SECRET;
          const accessToken = process.env.X_ACCESS_TOKEN;
          const accessTokenSecret = process.env.X_ACCESS_TOKEN_SECRET;

          function pct(s){return encodeURIComponent(s).replace(/[!*()']/g,c=>"%" + c.charCodeAt(0).toString(16));}
          function nonce(){return crypto.randomBytes(16).toString("hex");}
          function ts(){return Math.floor(Date.now()/1000).toString();}

          function oauthHeader(method, url) {
            const u = new URL(url);
            const baseUrl = u.origin + u.pathname;
            const params = {
              oauth_consumer_key: apiKey,
              oauth_nonce: nonce(),
              oauth_signature_method: "HMAC-SHA1",
              oauth_timestamp: ts(),
              oauth_token: accessToken,
              oauth_version: "1.0",
            };
            const sorted = Object.keys(params).sort().map(k => `${pct(k)}=${pct(params[k])}`).join("&");
            const base = [method, pct(baseUrl), pct(sorted)].join("&");
            const key = `${pct(apiKeySecret)}&${pct(accessTokenSecret)}`;
            params.oauth_signature = crypto.createHmac("sha1", key).update(base).digest("base64");
            return "OAuth " + Object.keys(params).map(k => `${pct(k)}="${pct(params[k])}"`).join(", ");
          }

          function postJson(url, payload){
            return new Promise((resolve, reject) => {
              const body = Buffer.from(JSON.stringify(payload));
              const req = https.request(url, {
                method: "POST",
                headers: {
                  "Authorization": oauthHeader("POST", url),
                  "Content-Type": "application/json",
                  "Content-Length": body.length
                }
              }, res => {
                let data = "";
                res.on("data", c => data += c);
                res.on("end", () => {
                  if (res.statusCode < 200 || res.statusCode >= 300) return reject(new Error(`tweet failed ${res.statusCode}: ${data}`));
                  resolve(JSON.parse(data));
                });
              });
              req.on("error", reject);
              req.write(body);
              req.end();
            });
          }

          (async () => {
            const r = await postJson("https://api.twitter.com/2/tweets", { text });
            console.log("OK:", r);
          })().catch(e => { console.error(e); process.exit(1); });
          EOF
