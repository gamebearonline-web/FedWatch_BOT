name: FedWatch Image Post (GAS Trigger)

on:
  workflow_dispatch:
    inputs:
      mode:
        description: "pre or post"
        required: true
        default: "pre"
      text:
        description: "post text"
        required: true
        default: "ðŸŸ¡FOMCå‰æ—¥ï½œFedWatch"
      dry_run:
        description: "true/false"
        required: false
        default: "false"

jobs:
  post:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Select image
        id: img
        run: |
          if [ "${{ inputs.mode }}" = "post" ]; then
            echo "path=assets/fedwatch_post.png" >> $GITHUB_OUTPUT
          else
            echo "path=assets/fedwatch_pre.png" >> $GITHUB_OUTPUT
          fi

      - name: Check image exists
        run: |
          ls -la "${{ steps.img.outputs.path }}"

      # ã“ã“ã¯ã‚ãªãŸã®æ—¢å­˜ã®ã€ŒX API v2å¯¾å¿œãƒ»ç”»åƒãªã—æŠ•ç¨¿ã€å®Ÿè£…ã«åˆã‚ã›ã¦å·®ã—æ›¿ãˆã¦OK
      # ç”»åƒä»˜ãã«ã™ã‚‹ã®ã§ã€(1) media upload(v1.1) â†’ (2) tweet create(v2) ãŒå¿…è¦ã§ã™ã€‚
      - name: Post to X with image
        env:
          X_API_KEY: ${{ secrets.X_API_KEY }}
          X_API_KEY_SECRET: ${{ secrets.X_API_KEY_SECRET }}
          X_ACCESS_TOKEN: ${{ secrets.X_ACCESS_TOKEN }}
          X_ACCESS_TOKEN_SECRET: ${{ secrets.X_ACCESS_TOKEN_SECRET }}
        run: |
          if [ "${{ inputs.dry_run }}" = "true" ]; then
            echo "DRY RUN: mode=${{ inputs.mode }}"
            echo "DRY RUN: text=${{ inputs.text }}"
            echo "DRY RUN: image=${{ steps.img.outputs.path }}"
            exit 0
          fi

          sudo apt-get update -y
          sudo apt-get install -y jq

          # --- media upload (X API v1.1) ---
          # oauth1ç½²åãŒå¿…è¦ãªã®ã§ nodeã§å‡¦ç†ï¼ˆç°¡å˜ã§å®‰å®šï¼‰
          node -e '
            const fs = require("fs");
            const crypto = require("crypto");
            const https = require("https");
            const path = process.env.IMG_PATH;
            const text = process.env.TWEET_TEXT;

            const apiKey = process.env.X_API_KEY;
            const apiKeySecret = process.env.X_API_KEY_SECRET;
            const accessToken = process.env.X_ACCESS_TOKEN;
            const accessTokenSecret = process.env.X_ACCESS_TOKEN_SECRET;

            function pct(s){return encodeURIComponent(s).replace(/[!*()']/g, c => "%" + c.charCodeAt(0).toString(16).toUpperCase());}
            function nonce(){return crypto.randomBytes(16).toString("hex");}
            function ts(){return Math.floor(Date.now()/1000).toString();}

            function oauthHeader(method, url, extraParams){
              const u = new URL(url);
              const baseUrl = u.origin + u.pathname;

              const params = {
                oauth_consumer_key: apiKey,
                oauth_nonce: nonce(),
                oauth_signature_method: "HMAC-SHA1",
                oauth_timestamp: ts(),
                oauth_token: accessToken,
                oauth_version: "1.0",
                ...(extraParams || {})
              };

              const sorted = Object.keys(params).sort().map(k => `${pct(k)}=${pct(params[k])}`).join("&");
              const base = [method.toUpperCase(), pct(baseUrl), pct(sorted)].join("&");
              const key = `${pct(apiKeySecret)}&${pct(accessTokenSecret)}`;
              const sig = crypto.createHmac("sha1", key).update(base).digest("base64");
              params.oauth_signature = sig;

              const header = "OAuth " + Object.keys(params)
                .filter(k => k.startsWith("oauth_"))
                .sort()
                .map(k => `${pct(k)}="${pct(params[k])}"`).join(", ");
              return header;
            }

            function postMultipart(url, filePath){
              return new Promise((resolve, reject) => {
                const boundary = "----fedwatch" + crypto.randomBytes(8).toString("hex");
                const file = fs.readFileSync(filePath);
                const head = Buffer.from(
                  `--${boundary}\r\n` +
                  `Content-Disposition: form-data; name="media"; filename="image.png"\r\n` +
                  `Content-Type: image/png\r\n\r\n`
                );
                const tail = Buffer.from(`\r\n--${boundary}--\r\n`);
                const body = Buffer.concat([head, file, tail]);

                const auth = oauthHeader("POST", url);
                const req = https.request(url, {
                  method: "POST",
                  headers: {
                    "Authorization": auth,
                    "Content-Type": `multipart/form-data; boundary=${boundary}`,
                    "Content-Length": body.length
                  }
                }, res => {
                  let data = "";
                  res.on("data", c => data += c);
                  res.on("end", () => {
                    if (res.statusCode < 200 || res.statusCode >= 300) return reject(new Error(`media upload failed ${res.statusCode}: ${data}`));
                    resolve(JSON.parse(data));
                  });
                });
                req.on("error", reject);
                req.write(body);
                req.end();
              });
            }

            function postJson(url, payload){
              return new Promise((resolve, reject) => {
                const body = Buffer.from(JSON.stringify(payload));
                const auth = oauthHeader("POST", url);
                const req = https.request(url, {
                  method: "POST",
                  headers: {
                    "Authorization": auth,
                    "Content-Type": "application/json",
                    "Content-Length": body.length
                  }
                }, res => {
                  let data = "";
                  res.on("data", c => data += c);
                  res.on("end", () => {
                    if (res.statusCode < 200 || res.statusCode >= 300) return reject(new Error(`tweet failed ${res.statusCode}: ${data}`));
                    resolve(JSON.parse(data));
                  });
                });
                req.on("error", reject);
                req.write(body);
                req.end();
              });
            }

            (async () => {
              const mediaRes = await postMultipart("https://upload.twitter.com/1.1/media/upload.json", path);
              const mediaId = mediaRes.media_id_string;
              const tweetRes = await postJson("https://api.twitter.com/2/tweets", {
                text,
                media: { media_ids: [mediaId] }
              });
              console.log("OK:", tweetRes);
            })().catch(e => { console.error(e); process.exit(1); });
          ' \
          IMG_PATH="${{ steps.img.outputs.path }}" \
          TWEET_TEXT="${{ inputs.text }}"
