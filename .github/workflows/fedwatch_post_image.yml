name: FedWatch Image Post (Auto Capture)

on:
  workflow_dispatch:
    inputs:
      mode:
        description: "pre or post"
        required: true
        default: "pre"
      text:
        description: "post text"
        required: true
      dry_run:
        description: "true/false"
        required: false
        default: "false"

jobs:
  post:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      # --- Playwright環境 ---
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install Playwright
        run: |
          npm init -y
          npm install playwright
          npx playwright install chromium

      # --- CME FedWatch をキャプチャ ---
      - name: Capture FedWatch Image
        run: |
          node << 'EOF'
          const { chromium } = require('playwright');
          (async () => {
            const browser = await chromium.launch();
            const page = await browser.newPage({
              viewport: { width: 1280, height: 900 }
            });

            await page.goto(
              'https://www.cmegroup.com/markets/interest-rates/cme-fedwatch-tool.html',
              { waitUntil: 'networkidle' }
            );

            // Cookie / banner 対策（あれば）
            await page.waitForTimeout(5000);

            // FedWatch の確率テーブル（DOM変更に強め）
            const target = await page.$('div.cmeFedWatchTool, table');
            if (!target) throw new Error('FedWatch table not found');

            await target.screenshot({ path: 'fedwatch.png' });

            await browser.close();
          })();
          EOF

      - name: Check image
        run: ls -lh fedwatch.png

      # --- 投稿（OAuth1） ---
      - name: Post to X
        env:
          X_API_KEY: ${{ secrets.X_API_KEY }}
          X_API_KEY_SECRET: ${{ secrets.X_API_KEY_SECRET }}
          X_ACCESS_TOKEN: ${{ secrets.X_ACCESS_TOKEN }}
          X_ACCESS_TOKEN_SECRET: ${{ secrets.X_ACCESS_TOKEN_SECRET }}
          TWEET_TEXT: ${{ inputs.text }}
          DRY_RUN: ${{ inputs.dry_run }}
        run: |
          if [ "$DRY_RUN" = "true" ]; then
            echo "DRY RUN"
            exit 0
          fi

          node << 'EOF'
          const fs = require("fs");
          const crypto = require("crypto");
          const https = require("https");

          const imagePath = "fedwatch.png";
          const text = process.env.TWEET_TEXT;

          const apiKey = process.env.X_API_KEY;
          const apiKeySecret = process.env.X_API_KEY_SECRET;
          const accessToken = process.env.X_ACCESS_TOKEN;
          const accessTokenSecret = process.env.X_ACCESS_TOKEN_SECRET;

          function pct(s){return encodeURIComponent(s).replace(/[!*()']/g,c=>"%" + c.charCodeAt(0).toString(16));}
          function nonce(){return crypto.randomBytes(16).toString("hex");}
          function ts(){return Math.floor(Date.now()/1000).toString();}

          function oauthHeader(method, url) {
            const u = new URL(url);
            const baseUrl = u.origin + u.pathname;
            const params = {
              oauth_consumer_key: apiKey,
              oauth_nonce: nonce(),
              oauth_signature_method: "HMAC-SHA1",
              oauth_timestamp: ts(),
              oauth_token: accessToken,
              oauth_version: "1.0",
            };
            const sorted = Object.keys(params).sort().map(k => `${pct(k)}=${pct(params[k])}`).join("&");
            const base = [method, pct(baseUrl), pct(sorted)].join("&");
            const key = `${pct(apiKeySecret)}&${pct(accessTokenSecret)}`;
            params.oauth_signature = crypto.createHmac("sha1", key).update(base).digest("base64");

            return "OAuth " + Object.keys(params)
              .map(k => `${pct(k)}="${pct(params[k])}"`).join(", ");
          }

          function uploadMedia() {
            return new Promise((resolve, reject) => {
              const boundary = "----fw" + crypto.randomBytes(6).toString("hex");
              const file = fs.readFileSync(imagePath);
              const body = Buffer.concat([
                Buffer.from(`--${boundary}\r\nContent-Disposition: form-data; name="media"; filename="fedwatch.png"\r\nContent-Type: image/png\r\n\r\n`),
                file,
                Buffer.from(`\r\n--${boundary}--`)
              ]);

              const req = https.request(
                "https://upload.twitter.com/1.1/media/upload.json",
                {
                  method: "POST",
                  headers: {
                    Authorization: oauthHeader("POST", "https://upload.twitter.com/1.1/media/upload.json"),
                    "Content-Type": `multipart/form-data; boundary=${boundary}`,
                    "Content-Length": body.length
                  }
                },
                res => {
                  let data = "";
                  res.on("data", c => data += c);
                  res.on("end", () => resolve(JSON.parse(data)));
                }
              );
              req.on("error", reject);
              req.write(body);
              req.end();
            });
          }

          function postTweet(mediaId) {
            return new Promise((resolve, reject) => {
              const body = JSON.stringify({
                text,
                media: { media_ids: [mediaId] }
              });

              const req = https.request(
                "https://api.twitter.com/2/tweets",
                {
                  method: "POST",
                  headers: {
                    Authorization: oauthHeader("POST", "https://api.twitter.com/2/tweets"),
                    "Content-Type": "application/json",
                    "Content-Length": Buffer.byteLength(body)
                  }
                },
                res => {
                  let data = "";
                  res.on("data", c => data += c);
                  res.on("end", () => resolve(data));
                }
              );
              req.on("error", reject);
              req.write(body);
              req.end();
            });
          }

          (async () => {
            const media = await uploadMedia();
            await postTweet(media.media_id_string);
            console.log("Posted with image");
          })();
          EOF
