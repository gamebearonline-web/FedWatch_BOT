name: FedWatch Image Post (JSON → Image)

on:
  workflow_dispatch:
    inputs:
      mode:
        description: "pre or post"
        required: true
        default: "pre"
      text:
        description: "post text"
        required: true
      dry_run:
        description: "true/false"
        required: false
        default: "false"

jobs:
  post:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      # --- Node 環境 ---
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20

      # --- 依存関係 ---
      - name: Install deps
        run: |
          npm init -y
          npm install canvas node-fetch@3

      # --- CME FedWatch JSON → 画像生成 ---
      - name: Generate FedWatch Image
        run: |
          node << 'EOF'
          import fetch from "node-fetch";
          import { createCanvas } from "canvas";
          import fs from "fs";

          // --- ① FedWatch JSON ---
          const res = await fetch(
            "https://www.cmegroup.com/CmeWS/mvc/FedWatch/GetFedWatchData"
          );
          if (!res.ok) throw new Error("Failed to fetch FedWatch JSON");
          const data = await res.json();

          const meetingDate = data.meetingDate || "FOMC";
          const rows = data.probabilities || [];

          if (rows.length === 0) {
            throw new Error("No probabilities in FedWatch JSON");
          }

          // --- ② Canvas で画像生成 ---
          const width = 900;
          const rowH = 48;
          const height = 140 + rows.length * rowH;

          const canvas = createCanvas(width, height);
          const ctx = canvas.getContext("2d");

          // 背景
          ctx.fillStyle = "#ffffff";
          ctx.fillRect(0, 0, width, height);

          // タイトル
          ctx.fillStyle = "#111";
          ctx.font = "bold 30px Sans";
          ctx.fillText("FedWatch Probabilities", 30, 42);

          ctx.font = "20px Sans";
          ctx.fillText(`Meeting: ${meetingDate}`, 30, 72);

          // ヘッダ
          let y = 110;
          ctx.font = "bold 20px Sans";
          ctx.fillText("Target Rate", 40, y);
          ctx.fillText("Probability", 360, y);

          y += 16;

          ctx.font = "20px Sans";

          rows.forEach(r => {
            y += rowH;
            const p = Number(r.probability);

            ctx.fillStyle = "#000";
            ctx.fillText(r.targetRate, 40, y);
            ctx.fillText(`${p.toFixed(1)}%`, 360, y);

            // バー
            ctx.fillStyle = "#2563eb";
            ctx.fillRect(480, y - 18, p * 3, 18);
          });

          fs.writeFileSync("fedwatch.png", canvas.toBuffer("image/png"));
          console.log("fedwatch.png generated");
          EOF

      - name: Check image
        run: ls -lh fedwatch.png

      # --- 投稿（OAuth1 / 既存ロジック） ---
      - name: Post to X
        env:
          X_API_KEY: ${{ secrets.X_API_KEY }}
          X_API_KEY_SECRET: ${{ secrets.X_API_KEY_SECRET }}
          X_ACCESS_TOKEN: ${{ secrets.X_ACCESS_TOKEN }}
          X_ACCESS_TOKEN_SECRET: ${{ secrets.X_ACCESS_TOKEN_SECRET }}
          TWEET_TEXT: ${{ inputs.text }}
          DRY_RUN: ${{ inputs.dry_run }}
        run: |
          if [ "$DRY_RUN" = "true" ]; then
            echo "DRY RUN"
            exit 0
          fi

          node << 'EOF'
          const fs = require("fs");
          const crypto = require("crypto");
          const https = require("https");

          const imagePath = "fedwatch.png";
          const text = process.env.TWEET_TEXT;

          const apiKey = process.env.X_API_KEY;
          const apiKeySecret = process.env.X_API_KEY_SECRET;
          const accessToken = process.env.X_ACCESS_TOKEN;
          const accessTokenSecret = process.env.X_ACCESS_TOKEN_SECRET;

          function pct(s){return encodeURIComponent(s).replace(/[!*()']/g,c=>"%" + c.charCodeAt(0).toString(16));}
          function nonce(){return crypto.randomBytes(16).toString("hex");}
          function ts(){return Math.floor(Date.now()/1000).toString();}

          function oauthHeader(method, url) {
            const u = new URL(url);
            const baseUrl = u.origin + u.pathname;
            const params = {
              oauth_consumer_key: apiKey,
              oauth_nonce: nonce(),
              oauth_signature_method: "HMAC-SHA1",
              oauth_timestamp: ts(),
              oauth_token: accessToken,
              oauth_version: "1.0",
            };
            const sorted = Object.keys(params).sort().map(k => `${pct(k)}=${pct(params[k])}`).join("&");
            const base = [method, pct(baseUrl), pct(sorted)].join("&");
            const key = `${pct(apiKeySecret)}&${pct(accessTokenSecret)}`;
            params.oauth_signature = crypto.createHmac("sha1", key).update(base).digest("base64");

            return "OAuth " + Object.keys(params)
              .map(k => `${pct(k)}="${pct(params[k])}"`).join(", ");
          }

          function uploadMedia() {
            return new Promise((resolve, reject) => {
              const boundary = "----fw" + crypto.randomBytes(6).toString("hex");
              const file = fs.readFileSync(imagePath);
              const body = Buffer.concat([
                Buffer.from(`--${boundary}\r\nContent-Disposition: form-data; name="media"; filename="fedwatch.png"\r\nContent-Type: image/png\r\n\r\n`),
                file,
                Buffer.from(`\r\n--${boundary}--`)
              ]);

              const req = https.request(
                "https://upload.twitter.com/1.1/media/upload.json",
                {
                  method: "POST",
                  headers: {
                    Authorization: oauthHeader("POST", "https://upload.twitter.com/1.1/media/upload.json"),
                    "Content-Type": `multipart/form-data; boundary=${boundary}`,
                    "Content-Length": body.length
                  }
                },
                res => {
                  let data = "";
                  res.on("data", c => data += c);
                  res.on("end", () => resolve(JSON.parse(data)));
                }
              );
              req.on("error", reject);
              req.write(body);
              req.end();
            });
          }

          function postTweet(mediaId) {
            return new Promise((resolve, reject) => {
              const body = JSON.stringify({
                text,
                media: { media_ids: [mediaId] }
              });

              const req = https.request(
                "https://api.twitter.com/2/tweets",
                {
                  method: "POST",
                  headers: {
                    Authorization: oauthHeader("POST", "https://api.twitter.com/2/tweets"),
                    "Content-Type": "application/json",
                    "Content-Length": Buffer.byteLength(body)
                  }
                },
                res => {
                  let data = "";
                  res.on("data", c => data += c);
                  res.on("end", () => resolve(data));
                }
              );
              req.on("error", reject);
              req.write(body);
              req.end();
            });
          }

          (async () => {
            const media = await uploadMedia();
            await postTweet(media.media_id_string);
            console.log("Posted with image");
          })();
          EOF
